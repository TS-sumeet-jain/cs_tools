from __future__ import annotations

from typing import TYPE_CHECKING, Any, Literal, Optional, Union
import csv
import logging
import pathlib

import pydantic

from cs_tools.sync import utils as sync_utils
from cs_tools.sync.base import Syncer

from . import util

if TYPE_CHECKING:
    from cs_tools.sync.types import TableRows

log = logging.getLogger(__name__)


class CSV(Syncer):
    """Interact with a CSV file."""

    __manifest_path__ = pathlib.Path(__file__).parent / "MANIFEST.json"
    __syncer_name__ = "csv"

    directory: Union[pydantic.DirectoryPath, pydantic.NewPath]
    delimiter: str = "|"
    escape_character: str = "\\"
    # quoting: Literal["ALL", "NOT_NULL", "STRINGS", "MINIMAL"] = "MINIMAL"
    compression: Optional[Literal["gzip"]] = None
    date_time_format: str = "%Y-%m-%d %H:%M:%S"

    @pydantic.field_validator("delimiter", "escape_character", mode="after")
    @classmethod
    def _only_single_characters_allowed(cls, value: str, info: pydantic.ValidationInfo) -> str:
        if len(value) > 1:
            raise ValueError(f"{info.field_name} must be a one-character string")
        return value

    def dialect_and_format_parameters(self) -> dict[str, Any]:
        """The specification passed to csv.DictWriter"""
        # fmt: off
        parameters = {
            "delimiter": self.delimiter,
            # A one-character string used to separate fields.

            "doublequote": False,
            # When False, the escapechar is used as a prefix to the quotechar.

            "escapechar": self.escape_character,
            # A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and 
            # the quotechar if doublequote is False.

            "lineterminator": "\r\n",
            # The string used to terminate lines.

            "quotechar": '"',
            # A one-character string used to quote fields containing special characters, such as the delimiter or
            # quotechar, or which contain new-line characters.

            "quoting": csv.QUOTE_MINIMAL,
            # Controls when quotes should be generated by the writer and recognised by the reader.
            #
            #     QUOTE_ALL - quote all fields
            # QUOTE_NONNULL - quote all fields which are not None
            # QUOTE_STRINGS - quote all fields which are strings, if a field value is None an empty string is written
            # QUOTE_MINIMAL - only quote those fields which contain special characters (ie. any chars defined above)
        }
        # fmt: on
        return parameters

    def __repr__(self):
        return f"<CSVSyncer path='{self.directory}'>"

    # MANDATORY PROTOCOL MEMBERS

    def load(self, file_name: str) -> TableRows:
        """Read rows from a CSV file in the directory."""
        raise NotImplementedError
        # with self.file_reference(f"{directive}.csv", mode="r") as f:
        #     reader = csv.DictReader(f, **self.dialect_params())
        #     data = list(reader)

        # return data

    def dump(self, file_name: str, *, data: TableRows) -> None:
        """Write rows to a CSV file in the directory."""
        if not data:
            log.warning(f"no data to write to syncer {self}")
            return

        raise NotImplementedError
        # # in case we have the first row not include some data
        # header = max([_.keys() for _ in data])

        # with self.file_reference(f"{directive}.csv", mode="a") as f:
        #     writer = csv.DictWriter(f, fieldnames=header, **self.dialect_params())
        #     writer.writeheader()
        #     writer.writerows([util.clean_datetime(row, date_time_format=self.date_time_format) for row in data])
